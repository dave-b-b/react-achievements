"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[8204],{2918(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"guides/event-based-tracking","title":"Event-Based Tracking","description":"Event-based tracking uses semantic events to update achievements. Instead of updating metrics directly, you emit events that represent business actions (like \\"userScored\\" or \\"levelUp\\"), which are automatically mapped to metric updates.","source":"@site/guides/event-based-tracking.md","sourceDirName":"guides","slug":"/guides/event-based-tracking","permalink":"/react-achievements/docs/guides/event-based-tracking","draft":false,"unlisted":false,"editUrl":"https://github.com/dave-b-b/react-achievements/tree/main/docs/guides/event-based-tracking.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Direct Metric Updates","permalink":"/react-achievements/docs/guides/direct-updates"},"next":{"title":"Theming & Built-in UI","permalink":"/react-achievements/docs/guides/theming"}}');var s=t(4848),r=t(8453);const c={sidebar_position:2},a="Event-Based Tracking",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Setup",id:"setup",level:2},{value:"Creating the Engine",id:"creating-the-engine",level:3},{value:"Provider Integration",id:"provider-integration",level:3},{value:"Using the Hook",id:"using-the-hook",level:3},{value:"Event Mapping",id:"event-mapping",level:2},{value:"Direct String Mapping",id:"direct-string-mapping",level:3},{value:"MetricUpdater Functions",id:"metricupdater-functions",level:3},{value:"Multi-Metric Events",id:"multi-metric-events",level:3},{value:"Emitting Events",id:"emitting-events",level:2},{value:"Basic Event Emission",id:"basic-event-emission",level:3},{value:"Event Data Patterns",id:"event-data-patterns",level:3},{value:"TypeScript Type Safety",id:"typescript-type-safety",level:3},{value:"Listening to Engine Events",id:"listening-to-engine-events",level:2},{value:"Built-in Events",id:"built-in-events",level:3},{value:"Subscribing to Events",id:"subscribing-to-events",level:3},{value:"Multiple Event Listeners",id:"multiple-event-listeners",level:3},{value:"One-Time Listeners",id:"one-time-listeners",level:3},{value:"React Integration",id:"react-integration",level:2},{value:"Emitting from Components",id:"emitting-from-components",level:3},{value:"Emitting from Effects",id:"emitting-from-effects",level:3},{value:"Using with React State",id:"using-with-react-state",level:3},{value:"Framework-Agnostic Usage",id:"framework-agnostic-usage",level:2},{value:"Vanilla JavaScript",id:"vanilla-javascript",level:3},{value:"Vue Integration",id:"vue-integration",level:3},{value:"Angular Integration",id:"angular-integration",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"When to Use Event-Based Tracking",id:"when-to-use-event-based-tracking",level:2},{value:"Best For",id:"best-for",level:3},{value:"Advantages",id:"advantages",level:3},{value:"Trade-offs",id:"trade-offs",level:3},{value:"Migration from Direct Updates",id:"migration-from-direct-updates",level:2},{value:"Before (Direct Updates)",id:"before-direct-updates",level:3},{value:"After (Event-Based)",id:"after-event-based",level:3},{value:"Can Both Patterns Coexist?",id:"can-both-patterns-coexist",level:3},{value:"Comparison with Direct Updates",id:"comparison-with-direct-updates",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"event-based-tracking",children:"Event-Based Tracking"})}),"\n",(0,s.jsx)(n.p,{children:'Event-based tracking uses semantic events to update achievements. Instead of updating metrics directly, you emit events that represent business actions (like "userScored" or "levelUp"), which are automatically mapped to metric updates.'}),"\n",(0,s.jsx)(n.p,{children:"This pattern is framework-agnostic and provides better separation of concerns - ideal for larger applications or multi-framework projects."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["With event-based tracking, you create an ",(0,s.jsx)(n.code,{children:"AchievementEngine"})," instance outside of React and configure event mappings. Your application code emits semantic events, and the engine automatically updates the appropriate metrics based on your mapping configuration."]}),"\n",(0,s.jsx)(n.p,{children:"The engine is framework-agnostic - the same instance can be used in React, Vue, Angular, or vanilla JavaScript."}),"\n",(0,s.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(n.h3,{id:"creating-the-engine",children:"Creating the Engine"}),"\n",(0,s.jsxs)(n.p,{children:["First, create an ",(0,s.jsx)(n.code,{children:"AchievementEngine"})," instance outside of your React components:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { AchievementEngine } from 'react-achievements';\n\nconst achievements = {\n  score: {\n    100: { title: 'Century!', description: 'Score 100 points', icon: '\ud83c\udfc6' },\n    500: { title: 'High Scorer!', icon: '\u2b50' },\n  },\n  level: {\n    5: { title: 'Leveling Up', icon: '\ud83d\udcc8' },\n    10: { title: 'Double Digits', icon: '\ud83d\udd1f' }\n  }\n};\n\nconst eventMapping = {\n  'userScored': (data) => ({ score: data.points }),\n  'userLeveledUp': (data) => ({ level: data.level }),\n  'tutorialCompleted': () => ({ completedTutorial: true })\n};\n\nconst engine = new AchievementEngine({\n  achievements,\n  eventMapping,\n  storage: 'local' // 'local', 'memory', 'indexedDB', or custom\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"provider-integration",children:"Provider Integration"}),"\n",(0,s.jsxs)(n.p,{children:["Pass the engine to ",(0,s.jsx)(n.code,{children:"AchievementProvider"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { AchievementProvider } from 'react-achievements';\n\nfunction App() {\n  return (\n    <AchievementProvider engine={engine} useBuiltInUI={true}>\n      <YourApp />\n    </AchievementProvider>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-the-hook",children:"Using the Hook"}),"\n",(0,s.jsxs)(n.p,{children:["Access the engine in your components with ",(0,s.jsx)(n.code,{children:"useAchievementEngine()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useAchievementEngine } from 'react-achievements';\n\nfunction Game() {\n  const engine = useAchievementEngine();\n\n  const handleAction = () => {\n    // Emit semantic events\n    engine.emit('userScored', { points: 100 });\n  };\n\n  return <button onClick={handleAction}>Score Points</button>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-mapping",children:"Event Mapping"}),"\n",(0,s.jsx)(n.p,{children:"Event mapping is the core concept that makes event-based tracking powerful. It defines how your semantic events translate into metric updates."}),"\n",(0,s.jsx)(n.h3,{id:"direct-string-mapping",children:"Direct String Mapping"}),"\n",(0,s.jsx)(n.p,{children:"The simplest form maps an event name directly to a metric name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const eventMapping = {\n  'enemy:defeated': 'enemiesDefeated',\n  'item:collected': 'itemsCollected'\n};\n\n// Usage\nengine.emit('enemy:defeated', 10); // Sets enemiesDefeated to 10\nengine.emit('item:collected', 5);  // Sets itemsCollected to 5\n"})}),"\n",(0,s.jsx)(n.h3,{id:"metricupdater-functions",children:"MetricUpdater Functions"}),"\n",(0,s.jsx)(n.p,{children:"For more complex logic, use functions to transform event data into metric updates:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import type { MetricUpdater } from 'react-achievements';\n\nconst eventMapping = {\n  // Increment level, reset experience\n  'player:levelup': (eventData, currentMetrics) => {\n    const currentLevel = currentMetrics.level || 0;\n    return {\n      level: currentLevel + 1,\n      experience: 0 // Reset experience on level up\n    };\n  },\n\n  // Add experience points\n  'player:gain_exp': (eventData, currentMetrics) => {\n    const currentExp = currentMetrics.experience || 0;\n    return {\n      experience: currentExp + eventData.amount\n    };\n  }\n};\n\n// Usage\nengine.emit('player:levelup');\nengine.emit('player:gain_exp', { amount: 50 });\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"MetricUpdater Function Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type MetricUpdater = (\n  eventData: any,\n  currentMetrics: Record<string, any>\n) => Record<string, any>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multi-metric-events",children:"Multi-Metric Events"}),"\n",(0,s.jsx)(n.p,{children:"A single event can update multiple metrics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const eventMapping = {\n  'boss:defeated': (data, currentMetrics) => ({\n    score: (currentMetrics.score || 0) + data.scoreGained,\n    level: (currentMetrics.level || 1) + 1,\n    bossesDefeated: (currentMetrics.bossesDefeated || 0) + 1,\n    lastBossName: data.bossName\n  })\n};\n\n// Usage - one event updates four metrics\nengine.emit('boss:defeated', {\n  scoreGained: 250,\n  bossName: 'Dragon King'\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"emitting-events",children:"Emitting Events"}),"\n",(0,s.jsx)(n.h3,{id:"basic-event-emission",children:"Basic Event Emission"}),"\n",(0,s.jsxs)(n.p,{children:["Emit events using ",(0,s.jsx)(n.code,{children:"engine.emit(eventName, data)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function GameComponent() {\n  const engine = useAchievementEngine();\n\n  const handleUserScored = () => {\n    engine.emit('userScored', { points: 100 });\n  };\n\n  const handleLevelUp = () => {\n    engine.emit('userLeveledUp', { level: 5 });\n  };\n\n  const handleSimpleEvent = () => {\n    engine.emit('tutorialCompleted');\n  };\n\n  return (\n    <div>\n      <button onClick={handleUserScored}>Score 100</button>\n      <button onClick={handleLevelUp}>Level Up</button>\n      <button onClick={handleSimpleEvent}>Complete Tutorial</button>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"event-data-patterns",children:"Event Data Patterns"}),"\n",(0,s.jsx)(n.p,{children:"Events can carry simple values or complex objects:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Simple value\nengine.emit('buttonClicked', true);\n\n// Object with multiple properties\nengine.emit('userScored', {\n  points: 100,\n  multiplier: 2,\n  timestamp: Date.now()\n});\n\n// No data (boolean achievements)\nengine.emit('tutorialCompleted');\n\n// Array data\nengine.emit('itemsCollected', ['sword', 'shield', 'potion']);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"typescript-type-safety",children:"TypeScript Type Safety"}),"\n",(0,s.jsx)(n.p,{children:"Define event types for type-safe event emission:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface GameEvents {\n  'userScored': { points: number; multiplier?: number };\n  'userLeveledUp': { level: number };\n  'boss:defeated': { scoreGained: number; bossName: string };\n  'tutorialCompleted': void;\n}\n\n// Type-safe event mapping\nconst eventMapping: Record<keyof GameEvents, MetricUpdater | string> = {\n  'userScored': (data) => ({ score: data.points * (data.multiplier || 1) }),\n  'userLeveledUp': (data) => ({ level: data.level }),\n  'boss:defeated': (data) => ({\n    score: data.scoreGained,\n    lastBoss: data.bossName\n  }),\n  'tutorialCompleted': () => ({ completedTutorial: true })\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"listening-to-engine-events",children:"Listening to Engine Events"}),"\n",(0,s.jsx)(n.p,{children:"The engine emits built-in events that you can listen to for notifications, analytics, or custom logic."}),"\n",(0,s.jsx)(n.h3,{id:"built-in-events",children:"Built-in Events"}),"\n",(0,s.jsx)(n.p,{children:"Four core events are available:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"achievement:unlocked"})})," - Fired when an achievement is unlocked"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"metric:updated"})})," - Fired when a metric value changes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"state:changed"})})," - Fired after any state change (metrics or achievements)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"error"})})," - Fired when an error occurs"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"subscribing-to-events",children:"Subscribing to Events"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"engine.on()"})," to subscribe to events:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useAchievementEngine } from 'react-achievements';\nimport { useEffect } from 'react';\n\nfunction NotificationHandler() {\n  const engine = useAchievementEngine();\n\n  useEffect(() => {\n    // Listen for achievement unlocks\n    const unsubscribe = engine.on('achievement:unlocked', (event) => {\n      console.log(`\ud83c\udf89 ${event.achievementTitle}`);\n      console.log(event.achievementDescription);\n\n      // Custom notification logic\n      // event contains: achievementId, achievementTitle, achievementDescription, achievementIconKey, timestamp\n    });\n\n    // Cleanup on unmount\n    return () => unsubscribe();\n  }, [engine]);\n\n  return null;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Event Payloads:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface AchievementUnlockedEvent {\n  achievementId: string;\n  achievementTitle: string;\n  achievementDescription: string;\n  achievementIconKey?: string;\n  timestamp: number;\n}\n\ninterface MetricUpdatedEvent {\n  metric: string;\n  oldValue: any;\n  newValue: any;\n}\n\ninterface StateChangedEvent {\n  metrics: Record<string, any>;\n  unlockedAchievements: string[];\n}\n\ninterface ErrorEvent {\n  error: Error;\n  context?: string;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multiple-event-listeners",children:"Multiple Event Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Subscribe to multiple events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useEffect(() => {\n  const unsubscribeUnlocked = engine.on('achievement:unlocked', (event) => {\n    console.log('Achievement unlocked:', event.achievementTitle);\n  });\n\n  const unsubscribeMetric = engine.on('metric:updated', (event) => {\n    console.log(`${event.metric}: ${event.oldValue} \u2192 ${event.newValue}`);\n  });\n\n  const unsubscribeState = engine.on('state:changed', (event) => {\n    console.log('State changed:', event);\n  });\n\n  return () => {\n    unsubscribeUnlocked();\n    unsubscribeMetric();\n    unsubscribeState();\n  };\n}, [engine]);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"one-time-listeners",children:"One-Time Listeners"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"engine.once()"})," to listen for an event just once:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useEffect(() => {\n  // Trigger confetti only on first achievement\n  engine.once('achievement:unlocked', (event) => {\n    console.log('First achievement unlocked!', event.achievementTitle);\n    // Show special first-time celebration\n  });\n}, [engine]);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"react-integration",children:"React Integration"}),"\n",(0,s.jsx)(n.h3,{id:"emitting-from-components",children:"Emitting from Components"}),"\n",(0,s.jsx)(n.p,{children:"Emit events in response to user actions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function GameControls() {\n  const engine = useAchievementEngine();\n  const [score, setScore] = useState(0);\n\n  const handleScorePoints = (points: number) => {\n    const newScore = score + points;\n    setScore(newScore);\n\n    // Emit event instead of direct metric update\n    engine.emit('userScored', { points: newScore });\n  };\n\n  return (\n    <div>\n      <p>Score: {score}</p>\n      <button onClick={() => handleScorePoints(100)}>+100 Points</button>\n      <button onClick={() => handleScorePoints(500)}>+500 Points</button>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"emitting-from-effects",children:"Emitting from Effects"}),"\n",(0,s.jsx)(n.p,{children:"Emit events when React state changes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useEffect } from 'react';\n\nfunction PlayerProgress({ player }) {\n  const engine = useAchievementEngine();\n\n  // Track level changes\n  useEffect(() => {\n    if (player.level > 1) {\n      engine.emit('userLeveledUp', { level: player.level });\n    }\n  }, [player.level, engine]);\n\n  // Track game completion\n  useEffect(() => {\n    if (player.gameComplete) {\n      engine.emit('gameCompleted', {\n        difficulty: player.difficulty,\n        timeElapsed: player.timeElapsed\n      });\n    }\n  }, [player.gameComplete, engine]);\n\n  return <div>Level: {player.level}</div>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-with-react-state",children:"Using with React State"}),"\n",(0,s.jsx)(n.p,{children:"Synchronize events with your application state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function Game() {\n  const engine = useAchievementEngine();\n  const [gameState, setGameState] = useState({\n    score: 0,\n    level: 1,\n    enemiesDefeated: 0\n  });\n\n  const defeatEnemy = () => {\n    setGameState(prev => {\n      const newState = {\n        ...prev,\n        enemiesDefeated: prev.enemiesDefeated + 1,\n        score: prev.score + 10\n      };\n\n      // Emit event with new state\n      engine.emit('enemyDefeated', {\n        totalEnemies: newState.enemiesDefeated,\n        scoreGained: 10\n      });\n\n      return newState;\n    });\n  };\n\n  return (\n    <div>\n      <p>Score: {gameState.score}</p>\n      <p>Enemies Defeated: {gameState.enemiesDefeated}</p>\n      <button onClick={defeatEnemy}>Defeat Enemy</button>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"framework-agnostic-usage",children:"Framework-Agnostic Usage"}),"\n",(0,s.jsxs)(n.p,{children:["One of the key benefits of event-based tracking is that the ",(0,s.jsx)(n.code,{children:"AchievementEngine"})," works outside React."]}),"\n",(0,s.jsx)(n.h3,{id:"vanilla-javascript",children:"Vanilla JavaScript"}),"\n",(0,s.jsx)(n.p,{children:"Use the engine in plain JavaScript:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html>\n<head>\n  <script src=\"https://unpkg.com/achievements-engine\"><\/script>\n</head>\n<body>\n  <button id=\"scoreBtn\">Score 100 Points</button>\n\n  <script>\n    const engine = new AchievementEngine({\n      achievements: {\n        score: {\n          100: { title: 'Century!', description: 'Score 100 points', icon: '\ud83c\udfc6' }\n        }\n      },\n      eventMapping: {\n        'userScored': (data) => ({ score: data.points })\n      },\n      storage: 'local'\n    });\n\n    // Listen for achievements\n    engine.on('achievement:unlocked', (event) => {\n      alert(`Achievement Unlocked: ${event.achievementTitle}`);\n    });\n\n    // Emit events from vanilla JS\n    document.getElementById('scoreBtn').addEventListener('click', () => {\n      engine.emit('userScored', { points: 100 });\n    });\n  <\/script>\n</body>\n</html>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"vue-integration",children:"Vue Integration"}),"\n",(0,s.jsx)(n.p,{children:"Share the same engine with Vue:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-vue",children:"<template>\n  <div>\n    <button @click=\"scorePoints\">Score 100 Points</button>\n  </div>\n</template>\n\n<script>\nimport { engine } from './achievementEngine';\n\nexport default {\n  methods: {\n    scorePoints() {\n      engine.emit('userScored', { points: 100 });\n    }\n  },\n\n  mounted() {\n    this.unsubscribe = engine.on('achievement:unlocked', (event) => {\n      console.log('Achievement unlocked:', event.achievementTitle);\n    });\n  },\n\n  beforeUnmount() {\n    this.unsubscribe();\n  }\n}\n<\/script>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"angular-integration",children:"Angular Integration"}),"\n",(0,s.jsx)(n.p,{children:"Use the engine in Angular services:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Injectable } from '@angular/core';\nimport { engine } from './achievementEngine';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AchievementService {\n  private unsubscribe: () => void;\n\n  constructor() {\n    this.unsubscribe = engine.on('achievement:unlocked', (event) => {\n      console.log('Achievement unlocked:', event.achievementTitle);\n    });\n  }\n\n  scorePoints(points: number) {\n    engine.emit('userScored', { points });\n  }\n\n  ngOnDestroy() {\n    this.unsubscribe();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's a full working example combining event mapping, event emission, and event listening:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="achievementEngine.ts"',children:"import { AchievementEngine } from 'react-achievements';\n\n// Achievement configuration\nexport const gameAchievements = {\n  score: {\n    100: { title: 'Century!', description: 'Score 100 points', icon: '\ud83c\udfc6' },\n    500: { title: 'High Scorer!', description: 'Score 500 points', icon: '\u2b50' },\n    1000: { title: 'Master!', description: 'Score 1000 points', icon: '\ud83d\udc8e' }\n  },\n  level: {\n    5: { title: 'Leveling Up', description: 'Reach level 5', icon: '\ud83d\udcc8' },\n    10: { title: 'Double Digits', description: 'Reach level 10', icon: '\ud83d\udd1f' }\n  },\n  enemiesDefeated: {\n    10: { title: 'Novice Slayer', description: 'Defeat 10 enemies', icon: '\u2694\ufe0f' },\n    50: { title: 'Expert Slayer', description: 'Defeat 50 enemies', icon: '\ud83d\udde1\ufe0f' }\n  },\n  completedTutorial: {\n    true: { title: 'Tutorial Master', description: 'Complete the tutorial', icon: '\ud83d\udcda' }\n  }\n};\n\n// Event mapping\nexport const eventMapping = {\n  'userScored': (data) => ({ score: data.points }),\n\n  'userLeveledUp': (data) => ({ level: data.level }),\n\n  'enemyDefeated': (data, currentMetrics) => ({\n    enemiesDefeated: (currentMetrics.enemiesDefeated || 0) + 1\n  }),\n\n  'tutorialCompleted': () => ({ completedTutorial: true }),\n\n  // Multi-metric event\n  'bossDefeated': (data, currentMetrics) => ({\n    score: (currentMetrics.score || 0) + data.scoreGained,\n    level: (currentMetrics.level || 1) + 1,\n    enemiesDefeated: (currentMetrics.enemiesDefeated || 0) + 1\n  })\n};\n\n// Create engine instance\nexport const engine = new AchievementEngine({\n  achievements: gameAchievements,\n  eventMapping,\n  storage: 'local'\n});\n\n// Listen for achievement unlocks\nengine.on('achievement:unlocked', (event) => {\n  console.log(`\ud83c\udf89 ${event.achievementTitle}`);\n  console.log(event.achievementDescription);\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="App.tsx"',children:"import { AchievementProvider } from 'react-achievements';\nimport { engine } from './achievementEngine';\nimport Game from './Game';\n\nfunction App() {\n  return (\n    <AchievementProvider engine={engine} useBuiltInUI={true}>\n      <Game />\n    </AchievementProvider>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="Game.tsx"',children:"import { useAchievementEngine } from 'react-achievements';\nimport { useState } from 'react';\n\nfunction Game() {\n  const engine = useAchievementEngine();\n  const [currentScore, setCurrentScore] = useState(0);\n  const [currentLevel, setCurrentLevel] = useState(1);\n\n  const handleScorePoints = (points: number) => {\n    const newScore = currentScore + points;\n    setCurrentScore(newScore);\n\n    // Emit semantic event\n    engine.emit('userScored', { points: newScore });\n  };\n\n  const handleLevelUp = () => {\n    const newLevel = currentLevel + 1;\n    setCurrentLevel(newLevel);\n\n    engine.emit('userLeveledUp', { level: newLevel });\n  };\n\n  const handleDefeatEnemy = () => {\n    engine.emit('enemyDefeated');\n  };\n\n  const handleBossDefeat = () => {\n    const scoreGained = 250;\n    const newScore = currentScore + scoreGained;\n    const newLevel = currentLevel + 1;\n\n    setCurrentScore(newScore);\n    setCurrentLevel(newLevel);\n\n    // Single event updates multiple metrics\n    engine.emit('bossDefeated', { scoreGained });\n  };\n\n  return (\n    <div>\n      <h1>Game</h1>\n      <p>Score: {currentScore}</p>\n      <p>Level: {currentLevel}</p>\n\n      <div>\n        <button onClick={() => handleScorePoints(100)}>+100 Points</button>\n        <button onClick={() => handleScorePoints(500)}>+500 Points</button>\n        <button onClick={handleLevelUp}>Level Up</button>\n        <button onClick={handleDefeatEnemy}>Defeat Enemy</button>\n        <button onClick={handleBossDefeat}>Defeat Boss (Multi-Metric)</button>\n        <button onClick={() => engine.emit('tutorialCompleted')}>\n          Complete Tutorial\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default Game;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-event-based-tracking",children:"When to Use Event-Based Tracking"}),"\n",(0,s.jsx)(n.h3,{id:"best-for",children:"Best For"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-framework projects"})," - Share the same engine across React, Vue, Angular"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Large applications"})," - Better separation of concerns for complex business logic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Semantic event names"}),' - "userScored" is clearer than "score: 100"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testability"})," - Events are easier to mock and test than direct metric updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Domain-driven design"})," - Events represent business actions"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"advantages",children:"Advantages"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Framework agnostic"})," - Use the same engine anywhere"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Semantic events"})," - Better developer experience with meaningful event names"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event mapping"})," - One event can update multiple metrics automatically"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Easier testing"})," - Test event emission separately from achievement logic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Separation of concerns"})," - Business logic decoupled from achievement tracking"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event listeners"})," - React to achievements with custom logic"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"trade-offs",children:"Trade-offs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"More setup code"})," - Creating engine and event mapping requires additional configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Additional concept"})," - Need to understand event-driven architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Slight learning curve"})," - More concepts than direct updates (engine, mapping, events)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"migration-from-direct-updates",children:"Migration from Direct Updates"}),"\n",(0,s.jsx)(n.p,{children:"You can migrate from direct updates to event-based tracking incrementally:"}),"\n",(0,s.jsx)(n.h3,{id:"before-direct-updates",children:"Before (Direct Updates)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Old pattern\n<AchievementProvider achievements={config}>\n  <App />\n</AchievementProvider>\n\n// In component\nconst { track } = useSimpleAchievements();\ntrack('score', 100);\ntrack('completedTutorial', true);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"after-event-based",children:"After (Event-Based)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// New pattern - create engine\nconst engine = new AchievementEngine({\n  achievements: config,\n  eventMapping: {\n    'userScored': (data) => ({ score: data.points }),\n    'tutorialCompleted': () => ({ completedTutorial: true })\n  }\n});\n\n<AchievementProvider engine={engine}>\n  <App />\n</AchievementProvider>\n\n// In component\nconst engine = useAchievementEngine();\nengine.emit('userScored', { points: 100 });\nengine.emit('tutorialCompleted');\n"})}),"\n",(0,s.jsx)(n.h3,{id:"can-both-patterns-coexist",children:"Can Both Patterns Coexist?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"No"})," - The provider enforces one pattern per app. However, you can:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use different patterns in different applications"}),"\n",(0,s.jsx)(n.li,{children:"Migrate one component at a time by creating a new provider with the engine pattern"}),"\n",(0,s.jsx)(n.li,{children:"The engine created internally by the old pattern can emit events, but doesn't use event mapping"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"comparison-with-direct-updates",children:"Comparison with Direct Updates"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"Direct Updates"}),(0,s.jsx)(n.th,{children:"Event-Based Tracking"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Setup"})}),(0,s.jsxs)(n.td,{children:["Pass ",(0,s.jsx)(n.code,{children:"achievements"})," to provider"]}),(0,s.jsx)(n.td,{children:"Create engine, pass to provider"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"API"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"track('score', 100)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"engine.emit('userScored', { points: 100 })"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Semantics"})}),(0,s.jsx)(n.td,{children:"Direct metrics"}),(0,s.jsx)(n.td,{children:"Business events"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Framework"})}),(0,s.jsx)(n.td,{children:"React-only"}),(0,s.jsx)(n.td,{children:"Framework-agnostic"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Testing"})}),(0,s.jsx)(n.td,{children:"Test with components"}),(0,s.jsx)(n.td,{children:"Test events separately"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Multi-Metric"})}),(0,s.jsxs)(n.td,{children:["Call ",(0,s.jsx)(n.code,{children:"trackMultiple()"})]}),(0,s.jsx)(n.td,{children:"One event with mapping"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Event Listeners"})}),(0,s.jsx)(n.td,{children:"Not available"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"engine.on()"})," available"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Best For"})}),(0,s.jsx)(n.td,{children:"Simple React apps"}),(0,s.jsx)(n.td,{children:"Large/multi-framework apps"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Want to try direct updates?"})," See the ",(0,s.jsx)(n.a,{href:"./direct-updates",children:"Direct Updates Guide"})]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./direct-updates",children:"Direct Updates"})})," - Alternative tracking pattern using React hooks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./builder-api",children:"Builder API"})})," - Advanced achievement configuration patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../recipes/common-patterns",children:"Common Patterns"})})," - Ready-to-use achievement patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./data-portability",children:"Data Portability"})})," - Export and import achievement data"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>c,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function c(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);