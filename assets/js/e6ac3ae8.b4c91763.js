"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2837],{6975(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"guides/data-portability","title":"Data Portability","description":"Export and import achievement data for backups, cross-device sync, and cloud storage integration.","source":"@site/guides/data-portability.md","sourceDirName":"guides","slug":"/guides/data-portability","permalink":"/react-achievements/docs/guides/data-portability","draft":false,"unlisted":false,"editUrl":"https://github.com/dave-b-b/react-achievements/tree/main/docs/guides/data-portability.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling","permalink":"/react-achievements/docs/guides/error-handling"},"next":{"title":"Styling","permalink":"/react-achievements/docs/guides/styling"}}');var r=t(4848),s=t(8453);const o={sidebar_position:6},i="Data Portability",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Basic Export/Import",id:"basic-exportimport",level:2},{value:"Export Data",id:"export-data",level:3},{value:"Import Data",id:"import-data",level:3},{value:"Export Options",id:"export-options",level:2},{value:"Export Everything",id:"export-everything",level:3},{value:"Export Specific Achievements",id:"export-specific-achievements",level:3},{value:"Export with Metadata",id:"export-with-metadata",level:3},{value:"Import Strategies",id:"import-strategies",level:2},{value:"Replace Strategy (Default)",id:"replace-strategy-default",level:3},{value:"Merge Strategy",id:"merge-strategy",level:3},{value:"Additive Strategy",id:"additive-strategy",level:3},{value:"Backup to File",id:"backup-to-file",level:2},{value:"Download as JSON File",id:"download-as-json-file",level:3},{value:"Upload from File",id:"upload-from-file",level:3},{value:"Cloud Storage Integration",id:"cloud-storage-integration",level:2},{value:"AWS S3 Integration",id:"aws-s3-integration",level:3},{value:"Restore from S3",id:"restore-from-s3",level:3},{value:"List Available Backups",id:"list-available-backups",level:3},{value:"Azure Blob Storage Integration",id:"azure-blob-storage-integration",level:3},{value:"Restore from Azure",id:"restore-from-azure",level:3},{value:"Automatic Cloud Sync",id:"automatic-cloud-sync",level:2},{value:"Sync on Achievement Unlock",id:"sync-on-achievement-unlock",level:3},{value:"Periodic Auto-Backup",id:"periodic-auto-backup",level:3},{value:"Sync on App Start",id:"sync-on-app-start",level:3},{value:"Cross-Device Sync",id:"cross-device-sync",level:2},{value:"REST API Sync",id:"rest-api-sync",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Encrypt Sensitive Data",id:"1-encrypt-sensitive-data",level:3},{value:"2. Version Your Backups",id:"2-version-your-backups",level:3},{value:"3. Keep Multiple Backups",id:"3-keep-multiple-backups",level:3},{value:"4. Validate Before Import",id:"4-validate-before-import",level:3},{value:"5. Handle Import Errors Gracefully",id:"5-handle-import-errors-gracefully",level:3},{value:"Conflict Resolution",id:"conflict-resolution",level:2},{value:"Timestamp-Based Resolution",id:"timestamp-based-resolution",level:3},{value:"Value-Based Resolution",id:"value-based-resolution",level:3},{value:"Custom Resolution",id:"custom-resolution",level:3},{value:"Complete Backup System Example",id:"complete-backup-system-example",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"data-portability",children:"Data Portability"})}),"\n",(0,r.jsx)(n.p,{children:"Export and import achievement data for backups, cross-device sync, and cloud storage integration."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"React Achievements provides comprehensive data portability:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Export"})," achievement data as JSON"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Import"})," data with merge strategies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cloud storage"})," integration (AWS S3, Azure Blob Storage)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cross-device sync"})," via REST API"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backup and restore"})," functionality"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"basic-exportimport",children:"Basic Export/Import"}),"\n",(0,r.jsx)(n.h3,{id:"export-data",children:"Export Data"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useAchievements } from 'react-achievements';\n\nfunction BackupButton() {\n  const { exportData } = useAchievements();\n\n  const handleExport = () => {\n    const data = exportData();\n    console.log(data);  // JSON string\n  };\n\n  return <button onClick={handleExport}>Export Achievements</button>;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"import-data",children:"Import Data"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function RestoreButton() {\n  const { importData } = useAchievements();\n\n  const handleImport = (jsonData) => {\n    const result = importData(jsonData);\n\n    if (result.success) {\n      console.log(`Imported ${result.count} achievements`);\n    } else {\n      console.error(`Import failed: ${result.error}`);\n    }\n  };\n\n  return <button onClick={() => handleImport(backupData)}>Restore</button>;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"export-options",children:"Export Options"}),"\n",(0,r.jsx)(n.h3,{id:"export-everything",children:"Export Everything"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const data = exportData();  // All achievements and metrics\n"})}),"\n",(0,r.jsx)(n.h3,{id:"export-specific-achievements",children:"Export Specific Achievements"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const data = exportData({\n  achievementIds: ['score_100', 'level_10']\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"export-with-metadata",children:"Export with Metadata"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const data = exportData({\n  includeMetadata: true  // Includes timestamps, version, etc.\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exported Format:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "version": "3.7.0",\n  "exportedAt": "2025-12-23T10:30:00.000Z",\n  "achievements": {\n    "score_100": {\n      "id": "score_100",\n      "title": "Century!",\n      "unlockedAt": "2025-12-22T15:20:00.000Z",\n      "isUnlocked": true\n    }\n  },\n  "metrics": {\n    "score": 150,\n    "level": 5,\n    "completedTutorial": true\n  }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"import-strategies",children:"Import Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"replace-strategy-default",children:"Replace Strategy (Default)"}),"\n",(0,r.jsx)(n.p,{children:"Completely replaces existing data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"importData(jsonData, { strategy: 'replace' });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Restoring from a known good backup"}),"\n",(0,r.jsx)(n.li,{children:"Resetting all achievements"}),"\n",(0,r.jsx)(n.li,{children:"Initial data load"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"merge-strategy",children:"Merge Strategy"}),"\n",(0,r.jsx)(n.p,{children:"Combines imported data with existing data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"importData(jsonData, { strategy: 'merge' });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Merge rules:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Unlocked achievements stay unlocked"}),"\n",(0,r.jsx)(n.li,{children:"Metrics take the higher value"}),"\n",(0,r.jsx)(n.li,{children:"Timestamps preserve the earliest unlock time"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Syncing between devices"}),"\n",(0,r.jsx)(n.li,{children:"Importing partial backups"}),"\n",(0,r.jsx)(n.li,{children:"Merging multiple saves"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"additive-strategy",children:"Additive Strategy"}),"\n",(0,r.jsx)(n.p,{children:"Only adds new achievements, never overwrites:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"importData(jsonData, { strategy: 'additive' });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Adding achievements from another source"}),"\n",(0,r.jsx)(n.li,{children:"Importing without losing progress"}),"\n",(0,r.jsx)(n.li,{children:"Safe imports"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"backup-to-file",children:"Backup to File"}),"\n",(0,r.jsx)(n.h3,{id:"download-as-json-file",children:"Download as JSON File"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function DownloadBackup() {\n  const { exportData } = useAchievements();\n\n  const handleDownload = () => {\n    const data = exportData({ includeMetadata: true });\n    const blob = new Blob([data], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = `achievements-backup-${Date.now()}.json`;\n    link.click();\n\n    URL.revokeObjectURL(url);\n  };\n\n  return <button onClick={handleDownload}>Download Backup</button>;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"upload-from-file",children:"Upload from File"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'function UploadBackup() {\n  const { importData } = useAchievements();\n\n  const handleFileChange = (event) => {\n    const file = event.target.files[0];\n    const reader = new FileReader();\n\n    reader.onload = (e) => {\n      const jsonData = e.target.result;\n      const result = importData(jsonData, { strategy: \'merge\' });\n\n      if (result.success) {\n        alert(`Restored ${result.count} achievements!`);\n      }\n    };\n\n    reader.readAsText(file);\n  };\n\n  return <input type="file" accept=".json" onChange={handleFileChange} />;\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cloud-storage-integration",children:"Cloud Storage Integration"}),"\n",(0,r.jsx)(n.h3,{id:"aws-s3-integration",children:"AWS S3 Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { S3 } from 'aws-sdk';\n\nasync function backupToS3() {\n  const { exportData } = useAchievements();\n  const data = exportData({ includeMetadata: true });\n\n  const s3 = new S3({\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    region: 'us-east-1'\n  });\n\n  const params = {\n    Bucket: 'my-achievements-backup',\n    Key: `users/${userId}/achievements-${Date.now()}.json`,\n    Body: data,\n    ContentType: 'application/json',\n    ServerSideEncryption: 'AES256'  // Encrypt at rest\n  };\n\n  try {\n    const result = await s3.putObject(params).promise();\n    console.log('Backed up to S3:', result);\n    return { success: true, location: result.Location };\n  } catch (error) {\n    console.error('S3 backup failed:', error);\n    return { success: false, error };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"restore-from-s3",children:"Restore from S3"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"async function restoreFromS3(backupKey) {\n  const { importData } = useAchievements();\n\n  const s3 = new S3({ /* credentials */ });\n\n  const params = {\n    Bucket: 'my-achievements-backup',\n    Key: backupKey\n  };\n\n  try {\n    const data = await s3.getObject(params).promise();\n    const jsonData = data.Body.toString('utf-8');\n\n    const result = importData(jsonData, { strategy: 'merge' });\n    console.log(`Restored ${result.count} achievements from S3`);\n    return result;\n  } catch (error) {\n    console.error('S3 restore failed:', error);\n    return { success: false, error };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"list-available-backups",children:"List Available Backups"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"async function listBackups(userId) {\n  const s3 = new S3({ /* credentials */ });\n\n  const params = {\n    Bucket: 'my-achievements-backup',\n    Prefix: `users/${userId}/`\n  };\n\n  const data = await s3.listObjectsV2(params).promise();\n\n  return data.Contents.map(item => ({\n    key: item.Key,\n    size: item.Size,\n    lastModified: item.LastModified\n  }));\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"azure-blob-storage-integration",children:"Azure Blob Storage Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { BlobServiceClient } from '@azure/storage-blob';\n\nasync function backupToAzure() {\n  const { exportData } = useAchievements();\n  const data = exportData({ includeMetadata: true });\n\n  const connectionString = process.env.AZURE_STORAGE_CONNECTION_STRING;\n  const blobServiceClient = BlobServiceClient.fromConnectionString(connectionString);\n\n  const containerName = 'achievements-backup';\n  const containerClient = blobServiceClient.getContainerClient(containerName);\n\n  const blobName = `users/${userId}/achievements-${Date.now()}.json`;\n  const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n\n  try {\n    await blockBlobClient.upload(data, data.length, {\n      blobHTTPHeaders: { blobContentType: 'application/json' }\n    });\n\n    console.log('Backed up to Azure Blob Storage');\n    return { success: true, blobName };\n  } catch (error) {\n    console.error('Azure backup failed:', error);\n    return { success: false, error };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"restore-from-azure",children:"Restore from Azure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"async function restoreFromAzure(blobName) {\n  const { importData } = useAchievements();\n\n  const connectionString = process.env.AZURE_STORAGE_CONNECTION_STRING;\n  const blobServiceClient = BlobServiceClient.fromConnectionString(connectionString);\n\n  const containerClient = blobServiceClient.getContainerClient('achievements-backup');\n  const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n\n  try {\n    const downloadResponse = await blockBlobClient.download(0);\n    const jsonData = await streamToString(downloadResponse.readableStreamBody);\n\n    const result = importData(jsonData, { strategy: 'merge' });\n    console.log(`Restored ${result.count} achievements from Azure`);\n    return result;\n  } catch (error) {\n    console.error('Azure restore failed:', error);\n    return { success: false, error };\n  }\n}\n\nasync function streamToString(readableStream) {\n  return new Promise((resolve, reject) => {\n    const chunks = [];\n    readableStream.on('data', (data) => {\n      chunks.push(data.toString());\n    });\n    readableStream.on('end', () => {\n      resolve(chunks.join(''));\n    });\n    readableStream.on('error', reject);\n  });\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"automatic-cloud-sync",children:"Automatic Cloud Sync"}),"\n",(0,r.jsx)(n.h3,{id:"sync-on-achievement-unlock",children:"Sync on Achievement Unlock"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"<AchievementProvider\n  achievements={achievements}\n  onAchievementUnlock={async (achievement) => {\n    // Backup to cloud whenever an achievement unlocks\n    await backupToS3();\n  }}\n>\n  <YourApp />\n</AchievementProvider>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"periodic-auto-backup",children:"Periodic Auto-Backup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function AppWithAutoBackup() {\n  const { exportData } = useAchievements();\n\n  useEffect(() => {\n    // Backup every 5 minutes\n    const interval = setInterval(async () => {\n      const data = exportData({ includeMetadata: true });\n      await backupToS3(data);\n    }, 5 * 60 * 1000);\n\n    return () => clearInterval(interval);\n  }, [exportData]);\n\n  return <YourApp />;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sync-on-app-start",children:"Sync on App Start"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function AppWithSync() {\n  const { importData } = useAchievements();\n  const [synced, setSynced] = useState(false);\n\n  useEffect(() => {\n    async function syncFromCloud() {\n      try {\n        const latestBackup = await getLatestBackup(userId);\n        const result = await restoreFromS3(latestBackup.key);\n\n        if (result.success) {\n          console.log('Synced from cloud');\n          setSynced(true);\n        }\n      } catch (error) {\n        console.error('Sync failed:', error);\n        setSynced(true);  // Continue anyway\n      }\n    }\n\n    syncFromCloud();\n  }, [importData]);\n\n  if (!synced) {\n    return <div>Syncing achievements...</div>;\n  }\n\n  return <YourApp />;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cross-device-sync",children:"Cross-Device Sync"}),"\n",(0,r.jsx)(n.h3,{id:"rest-api-sync",children:"REST API Sync"}),"\n",(0,r.jsx)(n.p,{children:"Use REST API storage for automatic cross-device sync:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"<AchievementProvider\n  achievements={achievements}\n  storage={StorageType.RestApi}\n  storageConfig={{\n    apiEndpoint: 'https://api.example.com/achievements',\n    userId: currentUser.id,\n    headers: {\n      'Authorization': `Bearer ${token}`\n    }\n  }}\n>\n  <YourApp />\n</AchievementProvider>\n"})}),"\n",(0,r.jsx)(n.p,{children:"The REST API storage automatically:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Syncs on every update"}),"\n",(0,r.jsx)(n.li,{children:"Pulls latest data on app start"}),"\n",(0,r.jsx)(n.li,{children:"Handles conflicts with merge strategy"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-encrypt-sensitive-data",children:"1. Encrypt Sensitive Data"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import CryptoJS from 'crypto-js';\n\nfunction encryptData(data, secret) {\n  return CryptoJS.AES.encrypt(data, secret).toString();\n}\n\nfunction decryptData(encryptedData, secret) {\n  const bytes = CryptoJS.AES.decrypt(encryptedData, secret);\n  return bytes.toString(CryptoJS.enc.Utf8);\n}\n\n// Export with encryption\nconst data = exportData();\nconst encrypted = encryptData(data, userSecret);\nawait backupToS3(encrypted);\n\n// Import with decryption\nconst encrypted = await restoreFromS3(backupKey);\nconst decrypted = decryptData(encrypted, userSecret);\nimportData(decrypted);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-version-your-backups",children:"2. Version Your Backups"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const backupKey = `users/${userId}/v${APP_VERSION}/achievements-${Date.now()}.json`;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-keep-multiple-backups",children:"3. Keep Multiple Backups"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// Keep last 10 backups, delete older ones\nasync function pruneOldBackups(userId, keepCount = 10) {\n  const backups = await listBackups(userId);\n\n  if (backups.length > keepCount) {\n    const toDelete = backups\n      .sort((a, b) => b.lastModified - a.lastModified)\n      .slice(keepCount);\n\n    for (const backup of toDelete) {\n      await s3.deleteObject({ Bucket: bucket, Key: backup.key }).promise();\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-validate-before-import",children:"4. Validate Before Import"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function validateBackupData(jsonData) {\n  try {\n    const parsed = JSON.parse(jsonData);\n\n    if (!parsed.version || !parsed.achievements) {\n      return { valid: false, error: 'Invalid backup format' };\n    }\n\n    // Check version compatibility\n    if (parsed.version !== CURRENT_VERSION) {\n      return { valid: false, error: 'Version mismatch' };\n    }\n\n    return { valid: true };\n  } catch (error) {\n    return { valid: false, error: 'Invalid JSON' };\n  }\n}\n\n// Use before importing\nconst validation = validateBackupData(data);\nif (validation.valid) {\n  importData(data);\n} else {\n  console.error('Invalid backup:', validation.error);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"5-handle-import-errors-gracefully",children:"5. Handle Import Errors Gracefully"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function safeImport(jsonData) {\n  try {\n    const result = importData(jsonData, { strategy: 'merge' });\n\n    if (!result.success) {\n      console.error('Import failed:', result.error);\n      // Show user-friendly message\n      showNotification('Could not restore backup', 'error');\n      return false;\n    }\n\n    showNotification(`Restored ${result.count} achievements`, 'success');\n    return true;\n  } catch (error) {\n    console.error('Import error:', error);\n    showNotification('Backup file is corrupted', 'error');\n    return false;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"conflict-resolution",children:"Conflict Resolution"}),"\n",(0,r.jsx)(n.h3,{id:"timestamp-based-resolution",children:"Timestamp-Based Resolution"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"importData(jsonData, {\n  strategy: 'merge',\n  conflictResolution: 'latest'  // Use most recent timestamp\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"value-based-resolution",children:"Value-Based Resolution"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"importData(jsonData, {\n  strategy: 'merge',\n  conflictResolution: 'highest'  // Use highest metric values\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-resolution",children:"Custom Resolution"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"importData(jsonData, {\n  strategy: 'merge',\n  conflictResolution: (local, remote) => {\n    // Custom logic\n    return local.score > remote.score ? local : remote;\n  }\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"complete-backup-system-example",children:"Complete Backup System Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useAchievements } from 'react-achievements';\nimport { S3 } from 'aws-sdk';\n\nfunction AchievementBackupSystem() {\n  const { exportData, importData } = useAchievements();\n  const [backups, setBackups] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    loadBackupList();\n  }, []);\n\n  async function loadBackupList() {\n    const list = await listBackups(userId);\n    setBackups(list);\n  }\n\n  async function createBackup() {\n    setLoading(true);\n    const data = exportData({ includeMetadata: true });\n    const result = await backupToS3(data);\n\n    if (result.success) {\n      await loadBackupList();\n      alert('Backup created successfully!');\n    } else {\n      alert('Backup failed: ' + result.error);\n    }\n    setLoading(false);\n  }\n\n  async function restore(backupKey) {\n    if (!confirm('This will merge the backup with your current progress. Continue?')) {\n      return;\n    }\n\n    setLoading(true);\n    const result = await restoreFromS3(backupKey);\n\n    if (result.success) {\n      alert(`Restored ${result.count} achievements!`);\n    } else {\n      alert('Restore failed: ' + result.error);\n    }\n    setLoading(false);\n  }\n\n  return (\n    <div className=\"backup-system\">\n      <h2>Achievement Backups</h2>\n\n      <button onClick={createBackup} disabled={loading}>\n        {loading ? 'Processing...' : 'Create Backup'}\n      </button>\n\n      <h3>Available Backups</h3>\n      <ul>\n        {backups.map(backup => (\n          <li key={backup.key}>\n            {new Date(backup.lastModified).toLocaleString()}\n            {' '}\n            ({(backup.size / 1024).toFixed(2)} KB)\n            <button onClick={() => restore(backup.key)}>Restore</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./error-handling",children:"Error Handling"})})," - Handle backup failures gracefully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"../api-reference",children:"API Reference"})})," - Complete export/import API docs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/guides/event-based-tracking",children:"Event-Based Tracking"})})," - Learn the event-driven pattern"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>i});var a=t(6540);const r={},s=a.createContext(r);function o(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);